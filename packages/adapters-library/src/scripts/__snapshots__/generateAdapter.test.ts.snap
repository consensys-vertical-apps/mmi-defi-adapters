// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`generateAdapter function snapshots should match snapshot for outcomes 0 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 1 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 2 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 3 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 4 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 5 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 6 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 7 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 8 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 9 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 10 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 11 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 12 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 13 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 14 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 15 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 16 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 17 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 18 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 19 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 20 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 21 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 22 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 23 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 24 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 25 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 26 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 27 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 28 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 29 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 30 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 31 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 32 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 33 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 34 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 35 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 36 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 37 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 38 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 39 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 40 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 41 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 42 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 43 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 44 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 45 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 46 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 47 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 48 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 49 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 50 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 51 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 52 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 53 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 54 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 55 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 56 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 57 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 58 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 59 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 60 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 61 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 62 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 63 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 64 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 65 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 66 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 67 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 68 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 69 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 70 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 71 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 72 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 73 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 74 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 75 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 76 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 77 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 78 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 79 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 80 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 81 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 82 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 83 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 84 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 85 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 86 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 87 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 88 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 89 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 90 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 91 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 92 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 93 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 94 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 95 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 96 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 97 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 98 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 99 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 100 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 101 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 102 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 103 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 104 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 105 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 106 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 107 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 108 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 109 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 110 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 111 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 112 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 113 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 114 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 115 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 116 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 117 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 118 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 119 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 120 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 121 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 122 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 123 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 124 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 125 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 126 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 127 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 128 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 129 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 130 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 131 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 132 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 133 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 134 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 135 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 136 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 137 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 138 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 139 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 140 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 141 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 142 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 143 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 144 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 145 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 146 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 147 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 148 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 149 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 150 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 151 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 152 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 153 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 154 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 155 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 156 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 157 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 158 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 159 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 160 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 161 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 162 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 163 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 164 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 165 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 166 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 167 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 168 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 169 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 170 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 171 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 172 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 173 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 174 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 175 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 176 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 177 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 178 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 179 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 180 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 181 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 182 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 183 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 184 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 185 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 186 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 187 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 188 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 189 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 190 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 191 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 192 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 193 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 194 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 195 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 196 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 197 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 198 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 199 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 200 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 201 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 202 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 203 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 204 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 205 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 206 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 207 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 208 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 209 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 210 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 211 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 212 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 213 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 214 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 215 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 216 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 217 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 218 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 219 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 220 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 221 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 222 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 223 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 224 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 225 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 226 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 227 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 228 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 229 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 230 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 231 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 232 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 233 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 234 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 235 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 236 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 237 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 238 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 239 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 240 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 241 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 242 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 243 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 244 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 245 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 246 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 247 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 248 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 249 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 250 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 251 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 252 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 253 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 254 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 255 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 256 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 257 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 258 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 259 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 260 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 261 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 262 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 263 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 264 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 265 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 266 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 267 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 268 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 269 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 270 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 271 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 272 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 273 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 274 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 275 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 276 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 277 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 278 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 279 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 280 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 281 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 282 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 283 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 284 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 285 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 286 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 287 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 288 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 289 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 290 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 291 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 292 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 293 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 294 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 295 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 296 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 297 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 298 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 299 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 300 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 301 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 302 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 303 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 304 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 305 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 306 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 307 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 308 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 309 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 310 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 311 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 312 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 313 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 314 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 315 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 316 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 317 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 318 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 319 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 320 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 321 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 322 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 323 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 324 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 325 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 326 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 327 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 328 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 329 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 330 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 331 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 332 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 333 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 334 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 335 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 336 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 337 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 338 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 339 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 340 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 341 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 342 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 343 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 344 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 345 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 346 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 347 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 348 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 349 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 350 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 351 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 352 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 353 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 354 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 355 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 356 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 357 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 358 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 359 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 360 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 361 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 362 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 363 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 364 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 365 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 366 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 367 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 368 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 369 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 370 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 371 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 372 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 373 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 374 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 375 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 376 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 377 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 378 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 379 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 380 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 381 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 382 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 383 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "addRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter extends RewardsAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    super()
                this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositionsWithoutRewards(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawalsWithoutRewards({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  async getRewardPositions({
                  userAddress,
                  protocolTokenAddress,
                  blockNumber,
                }: {
                  userAddress: string
                  blockNumber?: number
                  protocolTokenAddress: string
                }): Promise<Underlying[]> {
                  throw new NotImplementedError()
                }

  async getRewardWithdrawals({
                  userAddress,
                  protocolTokenAddress,
                }: GetEventsInput): Promise<MovementsByBlock[]> {
                  throw new NotImplementedError()
                }
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 384 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 385 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 386 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 387 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 388 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 389 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 390 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 391 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 392 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 393 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 394 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 395 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 396 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 397 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 398 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 399 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 400 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 401 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 402 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 403 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 404 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 405 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 406 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 407 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 408 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 409 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 410 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 411 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 412 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 413 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 414 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 415 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 416 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 417 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 418 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 419 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 420 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 421 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 422 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 423 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 424 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 425 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 426 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 427 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 428 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 429 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 430 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 431 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 432 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 433 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 434 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 435 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 436 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 437 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 438 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 439 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 440 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 441 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 442 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 443 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 444 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 445 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 446 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 447 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 448 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 449 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 450 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 451 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 452 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 453 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 454 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 455 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 456 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 457 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 458 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 459 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 460 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 461 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 462 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 463 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 464 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 465 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 466 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 467 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 468 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 469 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 470 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 471 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 472 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 473 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 474 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 475 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 476 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 477 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 478 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 479 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 480 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 481 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 482 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 483 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 484 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 485 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 486 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 487 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 488 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 489 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 490 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 491 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 492 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 493 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 494 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 495 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 496 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 497 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 498 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 499 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 500 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 501 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 502 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 503 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 504 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 505 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 506 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 507 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 508 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 509 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 510 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 511 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 512 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 513 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 514 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 515 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 516 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 517 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 518 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 519 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 520 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 521 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 522 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 523 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 524 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 525 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 526 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 527 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 528 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 529 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 530 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 531 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 532 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 533 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 534 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 535 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 536 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 537 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 538 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 539 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 540 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 541 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 542 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 543 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 544 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 545 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 546 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 547 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 548 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 549 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 550 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 551 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 552 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 553 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 554 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 555 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 556 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 557 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 558 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 559 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    return helpers.getBalanceOfTokens({
                ..._input,
                protocolTokens: await this.getProtocolTokens(),
                provider: this.provider
              })
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 560 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 561 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 562 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 563 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 564 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 565 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 566 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 567 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 568 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 569 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 570 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 571 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 572 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 573 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 574 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 575 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "useBalanceOfHelper",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 576 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 577 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 578 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 579 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 580 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 581 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 582 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 583 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 584 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 585 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 586 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 587 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 588 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 589 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 590 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 591 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 592 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 593 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 594 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 595 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 596 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 597 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 598 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 599 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 600 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 601 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 602 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 603 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 604 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 605 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 606 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 607 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokens = await helpers.getTokenMetadata(
                  getAddress('0x'),
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokens],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 608 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 609 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 610 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 611 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 612 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 613 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 614 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 615 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 616 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 617 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 618 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 619 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 620 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 621 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 622 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 623 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 624 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 625 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 626 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 627 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 628 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 629 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 630 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 631 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 632 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 633 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 634 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 635 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 636 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 637 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 638 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 639 1`] = `
[
  {
    "buildMetadataFunction": "singleProtocolToken",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    const protocolToken = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
            
                const underlyingTokensOne = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                const underlyingTokensTwo = await helpers.getTokenMetadata(
                  '0x',
                  this.chainId,
                  this.provider,
                )
                return {
                  [protocolToken.address]: {
                    protocolToken: protocolToken,
                    underlyingTokens: [underlyingTokensOne, underlyingTokensTwo],
                  },
                }
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 640 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 641 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 642 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 643 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 644 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 645 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 646 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 647 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 648 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 649 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 650 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 651 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 652 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 653 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 654 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 655 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 656 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 657 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 658 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 659 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 660 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 661 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 662 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 663 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 664 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 665 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 666 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 667 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 668 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 669 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 670 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 671 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 672 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 673 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 674 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 675 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 676 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 677 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 678 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 679 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 680 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 681 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 682 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 683 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 684 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 685 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 686 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 687 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 688 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 689 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 690 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 691 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 692 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 693 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 694 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 695 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 696 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 697 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 698 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 699 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 700 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 701 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 702 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 703 1`] = `
[
  {
    "buildMetadataFunction": "multipleProtocolTokens",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 704 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 705 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 706 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 707 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 708 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 709 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 710 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 711 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 712 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 713 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 714 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 715 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 716 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 717 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 718 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 719 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 720 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 721 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 722 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 723 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 724 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 725 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 726 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 727 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 728 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 729 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 730 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 731 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 732 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 733 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 734 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 735 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "oneUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 736 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 737 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 738 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 739 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 740 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 741 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 742 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 743 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "singleProtocolToken",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    return Object.values(await this.buildMetadata()).map(
                  ({ protocolToken }) => protocolToken,
                )
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 744 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 745 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 746 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 747 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 748 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 749 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 750 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 751 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "multipleProtocolTokens",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 752 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 753 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 754 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 755 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 756 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 757 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 758 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 759 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "nft",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 760 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 761 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 762 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 763 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "useOneToOneMethod",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    return helpers.unwrapOneToOne({
                  protocolToken: await this.getProtocolToken(_input.protocolTokenAddress),
                  underlyingTokens: await this.getUnderlyingTokens(_input.protocolTokenAddress)
                })
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 764 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 765 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "useWithdrawalHelper",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.withdrawals({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 766 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "useDepositsHelper",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    return helpers.deposits({
                  protocolToken: await this.getProtocolToken(protocolTokenAddress),
                  filter: { fromBlock, toBlock, userAddress },
                  provider: this.provider,
                })
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;

exports[`generateAdapter function snapshots should match snapshot for outcomes 767 1`] = `
[
  {
    "buildMetadataFunction": "notImplementedError",
    "defiAssetStructure": "contractPosition",
    "depositsFunction": "notImplementedError",
    "getPositions": "notImplementedError",
    "rewards": "noRewards",
    "template": "No",
    "underlyingTokens": "multipleUnderlying",
    "unwrap": "notImplementedError",
    "withdrawalsFunction": "notImplementedError",
  },
  "import { getAddress } from 'ethers'
import { Protocol } from '../../../protocols'
import { AdaptersController } from '../../../../core/adaptersController'
import { Chain } from '../../../../core/constants/chains'
import {
  IMetadataBuilder,
  CacheToFile,
} from '../../../../core/decorators/cacheToFile'
import { CustomJsonRpcProvider } from '../../../../core/provider/CustomJsonRpcProvider'
import { logger } from '../../../../core/utils/logger'
import {
  ProtocolAdapterParams,
  ProtocolDetails,
  PositionType,
  AssetType,
  GetPositionsInput,
  ProtocolPosition,
  GetEventsInput,
  MovementsByBlock,
  GetTotalValueLockedInput,
  ProtocolTokenTvl,
  UnwrapInput,
  UnwrapExchangeRate,
  Underlying,
} from '../../../../types/adapter'
import { Erc20Metadata } from '../../../../types/erc20Metadata'
import { IProtocolAdapter } from '../../../../types/IProtocolAdapter'
import { helpers } from '../../../../scripts/helpers'
import { RewardsAdapter } from '../../../../scripts/rewardAdapter'
import { NotImplementedError } from '../../../../core/errors/errors'
import { Replacements } from '../../../../scripts/replacements'

type Metadata = Record<
  string,
  {
    protocolToken: Erc20Metadata
    underlyingTokens: Erc20Metadata[]
  }
>

export class TestProtocolAdapter implements IProtocolAdapter, IMetadataBuilder {
  productId = 'testProtocolId'
  protocolId: Protocol
  chainId: Chain

  private provider: CustomJsonRpcProvider

  adaptersController: AdaptersController

  constructor({
    provider,
    chainId,
    protocolId,
    adaptersController,
  }: ProtocolAdapterParams) {
    this.provider = provider
    this.chainId = chainId
    this.protocolId = protocolId
    this.adaptersController = adaptersController
  }

  /**
   * Update me.
   * Add your protocol details
   */
  getProtocolDetails(): ProtocolDetails {
    return {
      protocolId: this.protocolId,
      name: 'TestProductKey',
      description: 'TestProductKey defi adapter',
      siteUrl: 'https:',
      iconUrl: 'https://',
      positionType: PositionType.Supply,
      chainId: this.chainId,
      productId: this.productId,
      assetDetails: {
        type: Replacements.ASSET_TYPE.placeholder,
      },
    }
  }

  @CacheToFile({ fileKey: 'protocol-token' })
  async buildMetadata(): Promise<Metadata> {
    throw new NotImplementedError()
  }

  async getProtocolTokens(): Promise<Erc20Metadata[]> {
    throw new NotImplementedError()
  }

  async getPositions(_input: GetPositionsInput): Promise<ProtocolPosition[]> {
    throw new NotImplementedError()
  }

  async getWithdrawals({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getDeposits({
    protocolTokenAddress,
    fromBlock,
    toBlock,
    userAddress,
  }: GetEventsInput): Promise<MovementsByBlock[]> {
    throw new NotImplementedError()
  }

  async getTotalValueLocked(
    _input: GetTotalValueLockedInput,
  ): Promise<ProtocolTokenTvl[]> {
    throw new NotImplementedError()
  }

  async unwrap(_input: UnwrapInput): Promise<UnwrapExchangeRate> {
    throw new NotImplementedError()
  }

  private async getProtocolToken(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).protocolToken
  }
  private async getUnderlyingTokens(protocolTokenAddress: string) {
    return (await this.fetchPoolMetadata(protocolTokenAddress)).underlyingTokens
  }

  private async fetchPoolMetadata(protocolTokenAddress: string) {
    const poolMetadata = (await this.buildMetadata())[protocolTokenAddress]

    if (!poolMetadata) {
      logger.error(
        {
          protocolTokenAddress,
          protocol: this.protocolId,
          chainId: this.chainId,
          product: this.productId,
        },
        'Protocol token pool not found',
      )
      throw new Error('Protocol token pool not found')
    }

    return poolMetadata
  }

  

  
}
",
]
`;
