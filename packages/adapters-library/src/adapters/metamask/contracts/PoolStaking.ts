/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "./common";

export declare namespace IKeeperValidators {
  export type ApprovalParamsStruct = {
    validatorsRegistryRoot: BytesLike;
    deadline: BigNumberish;
    validators: BytesLike;
    signatures: BytesLike;
    exitSignaturesIpfsHash: string;
  };

  export type ApprovalParamsStructOutput = [
    validatorsRegistryRoot: string,
    deadline: bigint,
    validators: string,
    signatures: string,
    exitSignaturesIpfsHash: string
  ] & {
    validatorsRegistryRoot: string;
    deadline: bigint;
    validators: string;
    signatures: string;
    exitSignaturesIpfsHash: string;
  };
}

export declare namespace IKeeperRewards {
  export type HarvestParamsStruct = {
    rewardsRoot: BytesLike;
    reward: BigNumberish;
    unlockedMevReward: BigNumberish;
    proof: BytesLike[];
  };

  export type HarvestParamsStructOutput = [
    rewardsRoot: string,
    reward: bigint,
    unlockedMevReward: bigint,
    proof: string[]
  ] & {
    rewardsRoot: string;
    reward: bigint;
    unlockedMevReward: bigint;
    proof: string[];
  };
}

export interface PoolStakingInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "UPGRADE_INTERFACE_VERSION"
      | "admin"
      | "blockedAccounts"
      | "blocklistManager"
      | "calculateExitedAssets"
      | "capacity"
      | "claimExitedAssets"
      | "convertToAssets"
      | "convertToShares"
      | "deposit"
      | "ejectUser"
      | "enterExitQueue"
      | "feePercent"
      | "feeRecipient"
      | "getExitQueueIndex"
      | "getShares"
      | "implementation"
      | "initialize"
      | "isStateUpdateRequired"
      | "keysManager"
      | "mevEscrow"
      | "multicall"
      | "proxiableUUID"
      | "queuedShares"
      | "receiveFromMevEscrow"
      | "redeem"
      | "registerValidator"
      | "registerValidators"
      | "setBlocklistManager"
      | "setFeeRecipient"
      | "setKeysManager"
      | "setMetadata"
      | "setValidatorsRoot"
      | "totalAssets"
      | "totalShares"
      | "updateBlocklist"
      | "updateState"
      | "updateStateAndDeposit"
      | "upgradeToAndCall"
      | "validatorIndex"
      | "validatorsRoot"
      | "vaultId"
      | "version"
      | "withdrawableAssets"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "BlocklistManagerUpdated"
      | "BlocklistUpdated"
      | "CheckpointCreated"
      | "Deposited"
      | "EthFoxVaultCreated"
      | "ExitQueueEntered"
      | "ExitedAssetsClaimed"
      | "FeeRecipientUpdated"
      | "FeeSharesMinted"
      | "Initialized"
      | "KeysManagerUpdated"
      | "MetadataUpdated"
      | "Redeemed"
      | "Upgraded"
      | "UserEjected"
      | "ValidatorRegistered"
      | "ValidatorsRootUpdated"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "UPGRADE_INTERFACE_VERSION",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "admin", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "blockedAccounts",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "blocklistManager",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "calculateExitedAssets",
    values: [AddressLike, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "capacity", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "claimExitedAssets",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "convertToAssets",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "convertToShares",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "deposit",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "ejectUser",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "enterExitQueue",
    values: [BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "feePercent",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "feeRecipient",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getExitQueueIndex",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getShares",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "implementation",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isStateUpdateRequired",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "keysManager",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "mevEscrow", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "multicall",
    values: [BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "proxiableUUID",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "queuedShares",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "receiveFromMevEscrow",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "redeem",
    values: [BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "registerValidator",
    values: [IKeeperValidators.ApprovalParamsStruct, BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "registerValidators",
    values: [
      IKeeperValidators.ApprovalParamsStruct,
      BigNumberish[],
      boolean[],
      BytesLike[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setBlocklistManager",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setFeeRecipient",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setKeysManager",
    values: [AddressLike]
  ): string;
  encodeFunctionData(functionFragment: "setMetadata", values: [string]): string;
  encodeFunctionData(
    functionFragment: "setValidatorsRoot",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "totalAssets",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "totalShares",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "updateBlocklist",
    values: [AddressLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "updateState",
    values: [IKeeperRewards.HarvestParamsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "updateStateAndDeposit",
    values: [AddressLike, AddressLike, IKeeperRewards.HarvestParamsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeToAndCall",
    values: [AddressLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "validatorIndex",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "validatorsRoot",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "vaultId", values?: undefined): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "withdrawableAssets",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "UPGRADE_INTERFACE_VERSION",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "admin", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "blockedAccounts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "blocklistManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculateExitedAssets",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "capacity", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "claimExitedAssets",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "convertToAssets",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "convertToShares",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "deposit", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "ejectUser", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "enterExitQueue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "feePercent", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "feeRecipient",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getExitQueueIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getShares", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "implementation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isStateUpdateRequired",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "keysManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "mevEscrow", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "multicall", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "proxiableUUID",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "queuedShares",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "receiveFromMevEscrow",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "redeem", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "registerValidator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerValidators",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setBlocklistManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setFeeRecipient",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setKeysManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMetadata",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setValidatorsRoot",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalAssets",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalShares",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateBlocklist",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateStateAndDeposit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "upgradeToAndCall",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "validatorIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "validatorsRoot",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "vaultId", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "withdrawableAssets",
    data: BytesLike
  ): Result;
}

export namespace BlocklistManagerUpdatedEvent {
  export type InputTuple = [caller: AddressLike, blocklistManager: AddressLike];
  export type OutputTuple = [caller: string, blocklistManager: string];
  export interface OutputObject {
    caller: string;
    blocklistManager: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace BlocklistUpdatedEvent {
  export type InputTuple = [
    caller: AddressLike,
    account: AddressLike,
    isBlocked: boolean
  ];
  export type OutputTuple = [
    caller: string,
    account: string,
    isBlocked: boolean
  ];
  export interface OutputObject {
    caller: string;
    account: string;
    isBlocked: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace CheckpointCreatedEvent {
  export type InputTuple = [shares: BigNumberish, assets: BigNumberish];
  export type OutputTuple = [shares: bigint, assets: bigint];
  export interface OutputObject {
    shares: bigint;
    assets: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace DepositedEvent {
  export type InputTuple = [
    caller: AddressLike,
    receiver: AddressLike,
    assets: BigNumberish,
    shares: BigNumberish,
    referrer: AddressLike
  ];
  export type OutputTuple = [
    caller: string,
    receiver: string,
    assets: bigint,
    shares: bigint,
    referrer: string
  ];
  export interface OutputObject {
    caller: string;
    receiver: string;
    assets: bigint;
    shares: bigint;
    referrer: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace EthFoxVaultCreatedEvent {
  export type InputTuple = [
    admin: AddressLike,
    ownMevEscrow: AddressLike,
    capacity: BigNumberish,
    feePercent: BigNumberish,
    metadataIpfsHash: string
  ];
  export type OutputTuple = [
    admin: string,
    ownMevEscrow: string,
    capacity: bigint,
    feePercent: bigint,
    metadataIpfsHash: string
  ];
  export interface OutputObject {
    admin: string;
    ownMevEscrow: string;
    capacity: bigint;
    feePercent: bigint;
    metadataIpfsHash: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ExitQueueEnteredEvent {
  export type InputTuple = [
    owner: AddressLike,
    receiver: AddressLike,
    positionTicket: BigNumberish,
    shares: BigNumberish
  ];
  export type OutputTuple = [
    owner: string,
    receiver: string,
    positionTicket: bigint,
    shares: bigint
  ];
  export interface OutputObject {
    owner: string;
    receiver: string;
    positionTicket: bigint;
    shares: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ExitedAssetsClaimedEvent {
  export type InputTuple = [
    receiver: AddressLike,
    prevPositionTicket: BigNumberish,
    newPositionTicket: BigNumberish,
    withdrawnAssets: BigNumberish
  ];
  export type OutputTuple = [
    receiver: string,
    prevPositionTicket: bigint,
    newPositionTicket: bigint,
    withdrawnAssets: bigint
  ];
  export interface OutputObject {
    receiver: string;
    prevPositionTicket: bigint;
    newPositionTicket: bigint;
    withdrawnAssets: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FeeRecipientUpdatedEvent {
  export type InputTuple = [caller: AddressLike, feeRecipient: AddressLike];
  export type OutputTuple = [caller: string, feeRecipient: string];
  export interface OutputObject {
    caller: string;
    feeRecipient: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FeeSharesMintedEvent {
  export type InputTuple = [
    receiver: AddressLike,
    shares: BigNumberish,
    assets: BigNumberish
  ];
  export type OutputTuple = [receiver: string, shares: bigint, assets: bigint];
  export interface OutputObject {
    receiver: string;
    shares: bigint;
    assets: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace InitializedEvent {
  export type InputTuple = [version: BigNumberish];
  export type OutputTuple = [version: bigint];
  export interface OutputObject {
    version: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace KeysManagerUpdatedEvent {
  export type InputTuple = [caller: AddressLike, keysManager: AddressLike];
  export type OutputTuple = [caller: string, keysManager: string];
  export interface OutputObject {
    caller: string;
    keysManager: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace MetadataUpdatedEvent {
  export type InputTuple = [caller: AddressLike, metadataIpfsHash: string];
  export type OutputTuple = [caller: string, metadataIpfsHash: string];
  export interface OutputObject {
    caller: string;
    metadataIpfsHash: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace RedeemedEvent {
  export type InputTuple = [
    owner: AddressLike,
    receiver: AddressLike,
    assets: BigNumberish,
    shares: BigNumberish
  ];
  export type OutputTuple = [
    owner: string,
    receiver: string,
    assets: bigint,
    shares: bigint
  ];
  export interface OutputObject {
    owner: string;
    receiver: string;
    assets: bigint;
    shares: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace UpgradedEvent {
  export type InputTuple = [implementation: AddressLike];
  export type OutputTuple = [implementation: string];
  export interface OutputObject {
    implementation: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace UserEjectedEvent {
  export type InputTuple = [user: AddressLike, shares: BigNumberish];
  export type OutputTuple = [user: string, shares: bigint];
  export interface OutputObject {
    user: string;
    shares: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ValidatorRegisteredEvent {
  export type InputTuple = [publicKey: BytesLike];
  export type OutputTuple = [publicKey: string];
  export interface OutputObject {
    publicKey: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ValidatorsRootUpdatedEvent {
  export type InputTuple = [caller: AddressLike, validatorsRoot: BytesLike];
  export type OutputTuple = [caller: string, validatorsRoot: string];
  export interface OutputObject {
    caller: string;
    validatorsRoot: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface PoolStaking extends BaseContract {
  connect(runner?: ContractRunner | null): PoolStaking;
  waitForDeployment(): Promise<this>;

  interface: PoolStakingInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  UPGRADE_INTERFACE_VERSION: TypedContractMethod<[], [string], "view">;

  admin: TypedContractMethod<[], [string], "view">;

  blockedAccounts: TypedContractMethod<[arg0: AddressLike], [boolean], "view">;

  blocklistManager: TypedContractMethod<[], [string], "view">;

  calculateExitedAssets: TypedContractMethod<
    [
      receiver: AddressLike,
      positionTicket: BigNumberish,
      timestamp: BigNumberish,
      exitQueueIndex: BigNumberish
    ],
    [
      [bigint, bigint, bigint] & {
        leftShares: bigint;
        claimedShares: bigint;
        claimedAssets: bigint;
      }
    ],
    "view"
  >;

  capacity: TypedContractMethod<[], [bigint], "view">;

  claimExitedAssets: TypedContractMethod<
    [
      positionTicket: BigNumberish,
      timestamp: BigNumberish,
      exitQueueIndex: BigNumberish
    ],
    [
      [bigint, bigint, bigint] & {
        newPositionTicket: bigint;
        claimedShares: bigint;
        claimedAssets: bigint;
      }
    ],
    "nonpayable"
  >;

  convertToAssets: TypedContractMethod<
    [shares: BigNumberish],
    [bigint],
    "view"
  >;

  convertToShares: TypedContractMethod<
    [assets: BigNumberish],
    [bigint],
    "view"
  >;

  deposit: TypedContractMethod<
    [receiver: AddressLike, referrer: AddressLike],
    [bigint],
    "payable"
  >;

  ejectUser: TypedContractMethod<[user: AddressLike], [void], "nonpayable">;

  enterExitQueue: TypedContractMethod<
    [shares: BigNumberish, receiver: AddressLike],
    [bigint],
    "nonpayable"
  >;

  feePercent: TypedContractMethod<[], [bigint], "view">;

  feeRecipient: TypedContractMethod<[], [string], "view">;

  getExitQueueIndex: TypedContractMethod<
    [positionTicket: BigNumberish],
    [bigint],
    "view"
  >;

  getShares: TypedContractMethod<[account: AddressLike], [bigint], "view">;

  implementation: TypedContractMethod<[], [string], "view">;

  initialize: TypedContractMethod<[params: BytesLike], [void], "payable">;

  isStateUpdateRequired: TypedContractMethod<[], [boolean], "view">;

  keysManager: TypedContractMethod<[], [string], "view">;

  mevEscrow: TypedContractMethod<[], [string], "view">;

  multicall: TypedContractMethod<[data: BytesLike[]], [string[]], "nonpayable">;

  proxiableUUID: TypedContractMethod<[], [string], "view">;

  queuedShares: TypedContractMethod<[], [bigint], "view">;

  receiveFromMevEscrow: TypedContractMethod<[], [void], "payable">;

  redeem: TypedContractMethod<
    [shares: BigNumberish, receiver: AddressLike],
    [bigint],
    "nonpayable"
  >;

  registerValidator: TypedContractMethod<
    [keeperParams: IKeeperValidators.ApprovalParamsStruct, proof: BytesLike[]],
    [void],
    "nonpayable"
  >;

  registerValidators: TypedContractMethod<
    [
      keeperParams: IKeeperValidators.ApprovalParamsStruct,
      indexes: BigNumberish[],
      proofFlags: boolean[],
      proof: BytesLike[]
    ],
    [void],
    "nonpayable"
  >;

  setBlocklistManager: TypedContractMethod<
    [_blocklistManager: AddressLike],
    [void],
    "nonpayable"
  >;

  setFeeRecipient: TypedContractMethod<
    [_feeRecipient: AddressLike],
    [void],
    "nonpayable"
  >;

  setKeysManager: TypedContractMethod<
    [keysManager_: AddressLike],
    [void],
    "nonpayable"
  >;

  setMetadata: TypedContractMethod<
    [metadataIpfsHash: string],
    [void],
    "nonpayable"
  >;

  setValidatorsRoot: TypedContractMethod<
    [_validatorsRoot: BytesLike],
    [void],
    "nonpayable"
  >;

  totalAssets: TypedContractMethod<[], [bigint], "view">;

  totalShares: TypedContractMethod<[], [bigint], "view">;

  updateBlocklist: TypedContractMethod<
    [account: AddressLike, isBlocked: boolean],
    [void],
    "nonpayable"
  >;

  updateState: TypedContractMethod<
    [harvestParams: IKeeperRewards.HarvestParamsStruct],
    [void],
    "nonpayable"
  >;

  updateStateAndDeposit: TypedContractMethod<
    [
      receiver: AddressLike,
      referrer: AddressLike,
      harvestParams: IKeeperRewards.HarvestParamsStruct
    ],
    [bigint],
    "payable"
  >;

  upgradeToAndCall: TypedContractMethod<
    [newImplementation: AddressLike, data: BytesLike],
    [void],
    "payable"
  >;

  validatorIndex: TypedContractMethod<[], [bigint], "view">;

  validatorsRoot: TypedContractMethod<[], [string], "view">;

  vaultId: TypedContractMethod<[], [string], "view">;

  version: TypedContractMethod<[], [bigint], "view">;

  withdrawableAssets: TypedContractMethod<[], [bigint], "view">;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "UPGRADE_INTERFACE_VERSION"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "admin"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "blockedAccounts"
  ): TypedContractMethod<[arg0: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "blocklistManager"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "calculateExitedAssets"
  ): TypedContractMethod<
    [
      receiver: AddressLike,
      positionTicket: BigNumberish,
      timestamp: BigNumberish,
      exitQueueIndex: BigNumberish
    ],
    [
      [bigint, bigint, bigint] & {
        leftShares: bigint;
        claimedShares: bigint;
        claimedAssets: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "capacity"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "claimExitedAssets"
  ): TypedContractMethod<
    [
      positionTicket: BigNumberish,
      timestamp: BigNumberish,
      exitQueueIndex: BigNumberish
    ],
    [
      [bigint, bigint, bigint] & {
        newPositionTicket: bigint;
        claimedShares: bigint;
        claimedAssets: bigint;
      }
    ],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "convertToAssets"
  ): TypedContractMethod<[shares: BigNumberish], [bigint], "view">;
  getFunction(
    nameOrSignature: "convertToShares"
  ): TypedContractMethod<[assets: BigNumberish], [bigint], "view">;
  getFunction(
    nameOrSignature: "deposit"
  ): TypedContractMethod<
    [receiver: AddressLike, referrer: AddressLike],
    [bigint],
    "payable"
  >;
  getFunction(
    nameOrSignature: "ejectUser"
  ): TypedContractMethod<[user: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "enterExitQueue"
  ): TypedContractMethod<
    [shares: BigNumberish, receiver: AddressLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "feePercent"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "feeRecipient"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "getExitQueueIndex"
  ): TypedContractMethod<[positionTicket: BigNumberish], [bigint], "view">;
  getFunction(
    nameOrSignature: "getShares"
  ): TypedContractMethod<[account: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "implementation"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "initialize"
  ): TypedContractMethod<[params: BytesLike], [void], "payable">;
  getFunction(
    nameOrSignature: "isStateUpdateRequired"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "keysManager"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "mevEscrow"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "multicall"
  ): TypedContractMethod<[data: BytesLike[]], [string[]], "nonpayable">;
  getFunction(
    nameOrSignature: "proxiableUUID"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "queuedShares"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "receiveFromMevEscrow"
  ): TypedContractMethod<[], [void], "payable">;
  getFunction(
    nameOrSignature: "redeem"
  ): TypedContractMethod<
    [shares: BigNumberish, receiver: AddressLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "registerValidator"
  ): TypedContractMethod<
    [keeperParams: IKeeperValidators.ApprovalParamsStruct, proof: BytesLike[]],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "registerValidators"
  ): TypedContractMethod<
    [
      keeperParams: IKeeperValidators.ApprovalParamsStruct,
      indexes: BigNumberish[],
      proofFlags: boolean[],
      proof: BytesLike[]
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setBlocklistManager"
  ): TypedContractMethod<
    [_blocklistManager: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setFeeRecipient"
  ): TypedContractMethod<[_feeRecipient: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setKeysManager"
  ): TypedContractMethod<[keysManager_: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setMetadata"
  ): TypedContractMethod<[metadataIpfsHash: string], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setValidatorsRoot"
  ): TypedContractMethod<[_validatorsRoot: BytesLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "totalAssets"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "totalShares"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "updateBlocklist"
  ): TypedContractMethod<
    [account: AddressLike, isBlocked: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "updateState"
  ): TypedContractMethod<
    [harvestParams: IKeeperRewards.HarvestParamsStruct],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "updateStateAndDeposit"
  ): TypedContractMethod<
    [
      receiver: AddressLike,
      referrer: AddressLike,
      harvestParams: IKeeperRewards.HarvestParamsStruct
    ],
    [bigint],
    "payable"
  >;
  getFunction(
    nameOrSignature: "upgradeToAndCall"
  ): TypedContractMethod<
    [newImplementation: AddressLike, data: BytesLike],
    [void],
    "payable"
  >;
  getFunction(
    nameOrSignature: "validatorIndex"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "validatorsRoot"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "vaultId"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "version"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "withdrawableAssets"
  ): TypedContractMethod<[], [bigint], "view">;

  getEvent(
    key: "BlocklistManagerUpdated"
  ): TypedContractEvent<
    BlocklistManagerUpdatedEvent.InputTuple,
    BlocklistManagerUpdatedEvent.OutputTuple,
    BlocklistManagerUpdatedEvent.OutputObject
  >;
  getEvent(
    key: "BlocklistUpdated"
  ): TypedContractEvent<
    BlocklistUpdatedEvent.InputTuple,
    BlocklistUpdatedEvent.OutputTuple,
    BlocklistUpdatedEvent.OutputObject
  >;
  getEvent(
    key: "CheckpointCreated"
  ): TypedContractEvent<
    CheckpointCreatedEvent.InputTuple,
    CheckpointCreatedEvent.OutputTuple,
    CheckpointCreatedEvent.OutputObject
  >;
  getEvent(
    key: "Deposited"
  ): TypedContractEvent<
    DepositedEvent.InputTuple,
    DepositedEvent.OutputTuple,
    DepositedEvent.OutputObject
  >;
  getEvent(
    key: "EthFoxVaultCreated"
  ): TypedContractEvent<
    EthFoxVaultCreatedEvent.InputTuple,
    EthFoxVaultCreatedEvent.OutputTuple,
    EthFoxVaultCreatedEvent.OutputObject
  >;
  getEvent(
    key: "ExitQueueEntered"
  ): TypedContractEvent<
    ExitQueueEnteredEvent.InputTuple,
    ExitQueueEnteredEvent.OutputTuple,
    ExitQueueEnteredEvent.OutputObject
  >;
  getEvent(
    key: "ExitedAssetsClaimed"
  ): TypedContractEvent<
    ExitedAssetsClaimedEvent.InputTuple,
    ExitedAssetsClaimedEvent.OutputTuple,
    ExitedAssetsClaimedEvent.OutputObject
  >;
  getEvent(
    key: "FeeRecipientUpdated"
  ): TypedContractEvent<
    FeeRecipientUpdatedEvent.InputTuple,
    FeeRecipientUpdatedEvent.OutputTuple,
    FeeRecipientUpdatedEvent.OutputObject
  >;
  getEvent(
    key: "FeeSharesMinted"
  ): TypedContractEvent<
    FeeSharesMintedEvent.InputTuple,
    FeeSharesMintedEvent.OutputTuple,
    FeeSharesMintedEvent.OutputObject
  >;
  getEvent(
    key: "Initialized"
  ): TypedContractEvent<
    InitializedEvent.InputTuple,
    InitializedEvent.OutputTuple,
    InitializedEvent.OutputObject
  >;
  getEvent(
    key: "KeysManagerUpdated"
  ): TypedContractEvent<
    KeysManagerUpdatedEvent.InputTuple,
    KeysManagerUpdatedEvent.OutputTuple,
    KeysManagerUpdatedEvent.OutputObject
  >;
  getEvent(
    key: "MetadataUpdated"
  ): TypedContractEvent<
    MetadataUpdatedEvent.InputTuple,
    MetadataUpdatedEvent.OutputTuple,
    MetadataUpdatedEvent.OutputObject
  >;
  getEvent(
    key: "Redeemed"
  ): TypedContractEvent<
    RedeemedEvent.InputTuple,
    RedeemedEvent.OutputTuple,
    RedeemedEvent.OutputObject
  >;
  getEvent(
    key: "Upgraded"
  ): TypedContractEvent<
    UpgradedEvent.InputTuple,
    UpgradedEvent.OutputTuple,
    UpgradedEvent.OutputObject
  >;
  getEvent(
    key: "UserEjected"
  ): TypedContractEvent<
    UserEjectedEvent.InputTuple,
    UserEjectedEvent.OutputTuple,
    UserEjectedEvent.OutputObject
  >;
  getEvent(
    key: "ValidatorRegistered"
  ): TypedContractEvent<
    ValidatorRegisteredEvent.InputTuple,
    ValidatorRegisteredEvent.OutputTuple,
    ValidatorRegisteredEvent.OutputObject
  >;
  getEvent(
    key: "ValidatorsRootUpdated"
  ): TypedContractEvent<
    ValidatorsRootUpdatedEvent.InputTuple,
    ValidatorsRootUpdatedEvent.OutputTuple,
    ValidatorsRootUpdatedEvent.OutputObject
  >;

  filters: {
    "BlocklistManagerUpdated(address,address)": TypedContractEvent<
      BlocklistManagerUpdatedEvent.InputTuple,
      BlocklistManagerUpdatedEvent.OutputTuple,
      BlocklistManagerUpdatedEvent.OutputObject
    >;
    BlocklistManagerUpdated: TypedContractEvent<
      BlocklistManagerUpdatedEvent.InputTuple,
      BlocklistManagerUpdatedEvent.OutputTuple,
      BlocklistManagerUpdatedEvent.OutputObject
    >;

    "BlocklistUpdated(address,address,bool)": TypedContractEvent<
      BlocklistUpdatedEvent.InputTuple,
      BlocklistUpdatedEvent.OutputTuple,
      BlocklistUpdatedEvent.OutputObject
    >;
    BlocklistUpdated: TypedContractEvent<
      BlocklistUpdatedEvent.InputTuple,
      BlocklistUpdatedEvent.OutputTuple,
      BlocklistUpdatedEvent.OutputObject
    >;

    "CheckpointCreated(uint256,uint256)": TypedContractEvent<
      CheckpointCreatedEvent.InputTuple,
      CheckpointCreatedEvent.OutputTuple,
      CheckpointCreatedEvent.OutputObject
    >;
    CheckpointCreated: TypedContractEvent<
      CheckpointCreatedEvent.InputTuple,
      CheckpointCreatedEvent.OutputTuple,
      CheckpointCreatedEvent.OutputObject
    >;

    "Deposited(address,address,uint256,uint256,address)": TypedContractEvent<
      DepositedEvent.InputTuple,
      DepositedEvent.OutputTuple,
      DepositedEvent.OutputObject
    >;
    Deposited: TypedContractEvent<
      DepositedEvent.InputTuple,
      DepositedEvent.OutputTuple,
      DepositedEvent.OutputObject
    >;

    "EthFoxVaultCreated(address,address,uint256,uint16,string)": TypedContractEvent<
      EthFoxVaultCreatedEvent.InputTuple,
      EthFoxVaultCreatedEvent.OutputTuple,
      EthFoxVaultCreatedEvent.OutputObject
    >;
    EthFoxVaultCreated: TypedContractEvent<
      EthFoxVaultCreatedEvent.InputTuple,
      EthFoxVaultCreatedEvent.OutputTuple,
      EthFoxVaultCreatedEvent.OutputObject
    >;

    "ExitQueueEntered(address,address,uint256,uint256)": TypedContractEvent<
      ExitQueueEnteredEvent.InputTuple,
      ExitQueueEnteredEvent.OutputTuple,
      ExitQueueEnteredEvent.OutputObject
    >;
    ExitQueueEntered: TypedContractEvent<
      ExitQueueEnteredEvent.InputTuple,
      ExitQueueEnteredEvent.OutputTuple,
      ExitQueueEnteredEvent.OutputObject
    >;

    "ExitedAssetsClaimed(address,uint256,uint256,uint256)": TypedContractEvent<
      ExitedAssetsClaimedEvent.InputTuple,
      ExitedAssetsClaimedEvent.OutputTuple,
      ExitedAssetsClaimedEvent.OutputObject
    >;
    ExitedAssetsClaimed: TypedContractEvent<
      ExitedAssetsClaimedEvent.InputTuple,
      ExitedAssetsClaimedEvent.OutputTuple,
      ExitedAssetsClaimedEvent.OutputObject
    >;

    "FeeRecipientUpdated(address,address)": TypedContractEvent<
      FeeRecipientUpdatedEvent.InputTuple,
      FeeRecipientUpdatedEvent.OutputTuple,
      FeeRecipientUpdatedEvent.OutputObject
    >;
    FeeRecipientUpdated: TypedContractEvent<
      FeeRecipientUpdatedEvent.InputTuple,
      FeeRecipientUpdatedEvent.OutputTuple,
      FeeRecipientUpdatedEvent.OutputObject
    >;

    "FeeSharesMinted(address,uint256,uint256)": TypedContractEvent<
      FeeSharesMintedEvent.InputTuple,
      FeeSharesMintedEvent.OutputTuple,
      FeeSharesMintedEvent.OutputObject
    >;
    FeeSharesMinted: TypedContractEvent<
      FeeSharesMintedEvent.InputTuple,
      FeeSharesMintedEvent.OutputTuple,
      FeeSharesMintedEvent.OutputObject
    >;

    "Initialized(uint64)": TypedContractEvent<
      InitializedEvent.InputTuple,
      InitializedEvent.OutputTuple,
      InitializedEvent.OutputObject
    >;
    Initialized: TypedContractEvent<
      InitializedEvent.InputTuple,
      InitializedEvent.OutputTuple,
      InitializedEvent.OutputObject
    >;

    "KeysManagerUpdated(address,address)": TypedContractEvent<
      KeysManagerUpdatedEvent.InputTuple,
      KeysManagerUpdatedEvent.OutputTuple,
      KeysManagerUpdatedEvent.OutputObject
    >;
    KeysManagerUpdated: TypedContractEvent<
      KeysManagerUpdatedEvent.InputTuple,
      KeysManagerUpdatedEvent.OutputTuple,
      KeysManagerUpdatedEvent.OutputObject
    >;

    "MetadataUpdated(address,string)": TypedContractEvent<
      MetadataUpdatedEvent.InputTuple,
      MetadataUpdatedEvent.OutputTuple,
      MetadataUpdatedEvent.OutputObject
    >;
    MetadataUpdated: TypedContractEvent<
      MetadataUpdatedEvent.InputTuple,
      MetadataUpdatedEvent.OutputTuple,
      MetadataUpdatedEvent.OutputObject
    >;

    "Redeemed(address,address,uint256,uint256)": TypedContractEvent<
      RedeemedEvent.InputTuple,
      RedeemedEvent.OutputTuple,
      RedeemedEvent.OutputObject
    >;
    Redeemed: TypedContractEvent<
      RedeemedEvent.InputTuple,
      RedeemedEvent.OutputTuple,
      RedeemedEvent.OutputObject
    >;

    "Upgraded(address)": TypedContractEvent<
      UpgradedEvent.InputTuple,
      UpgradedEvent.OutputTuple,
      UpgradedEvent.OutputObject
    >;
    Upgraded: TypedContractEvent<
      UpgradedEvent.InputTuple,
      UpgradedEvent.OutputTuple,
      UpgradedEvent.OutputObject
    >;

    "UserEjected(address,uint256)": TypedContractEvent<
      UserEjectedEvent.InputTuple,
      UserEjectedEvent.OutputTuple,
      UserEjectedEvent.OutputObject
    >;
    UserEjected: TypedContractEvent<
      UserEjectedEvent.InputTuple,
      UserEjectedEvent.OutputTuple,
      UserEjectedEvent.OutputObject
    >;

    "ValidatorRegistered(bytes)": TypedContractEvent<
      ValidatorRegisteredEvent.InputTuple,
      ValidatorRegisteredEvent.OutputTuple,
      ValidatorRegisteredEvent.OutputObject
    >;
    ValidatorRegistered: TypedContractEvent<
      ValidatorRegisteredEvent.InputTuple,
      ValidatorRegisteredEvent.OutputTuple,
      ValidatorRegisteredEvent.OutputObject
    >;

    "ValidatorsRootUpdated(address,bytes32)": TypedContractEvent<
      ValidatorsRootUpdatedEvent.InputTuple,
      ValidatorsRootUpdatedEvent.OutputTuple,
      ValidatorsRootUpdatedEvent.OutputObject
    >;
    ValidatorsRootUpdated: TypedContractEvent<
      ValidatorsRootUpdatedEvent.InputTuple,
      ValidatorsRootUpdatedEvent.OutputTuple,
      ValidatorsRootUpdatedEvent.OutputObject
    >;
  };
}
