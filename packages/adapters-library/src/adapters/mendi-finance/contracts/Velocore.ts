/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "./common";

export type PoolDataStruct = {
  pool: AddressLike;
  poolType: string;
  lpTokens: BytesLike[];
  mintedLPTokens: BigNumberish[];
  listedTokens: BytesLike[];
  reserves: BigNumberish[];
  poolParams: BytesLike;
};

export type PoolDataStructOutput = [
  pool: string,
  poolType: string,
  lpTokens: string[],
  mintedLPTokens: bigint[],
  listedTokens: string[],
  reserves: bigint[],
  poolParams: string
] & {
  pool: string;
  poolType: string;
  lpTokens: string[];
  mintedLPTokens: bigint[];
  listedTokens: string[];
  reserves: bigint[];
  poolParams: string;
};

export type BribeDataStruct = {
  tokens: BytesLike[];
  rates: BigNumberish[];
  userClaimable: BigNumberish[];
  userRates: BigNumberish[];
};

export type BribeDataStructOutput = [
  tokens: string[],
  rates: bigint[],
  userClaimable: bigint[],
  userRates: bigint[]
] & {
  tokens: string[];
  rates: bigint[];
  userClaimable: bigint[];
  userRates: bigint[];
};

export type GaugeDataStruct = {
  gauge: AddressLike;
  poolData: PoolDataStruct;
  killed: boolean;
  totalVotes: BigNumberish;
  userVotes: BigNumberish;
  userClaimable: BigNumberish;
  emissionRate: BigNumberish;
  userEmissionRate: BigNumberish;
  stakedValueInHubToken: BigNumberish;
  userStakedValueInHubToken: BigNumberish;
  averageInterestRatePerSecond: BigNumberish;
  userInterestRatePerSecond: BigNumberish;
  stakeableTokens: BytesLike[];
  stakedAmounts: BigNumberish[];
  userStakedAmounts: BigNumberish[];
  underlyingTokens: BytesLike[];
  stakedUnderlying: BigNumberish[];
  userUnderlying: BigNumberish[];
  bribes: BribeDataStruct[];
};

export type GaugeDataStructOutput = [
  gauge: string,
  poolData: PoolDataStructOutput,
  killed: boolean,
  totalVotes: bigint,
  userVotes: bigint,
  userClaimable: bigint,
  emissionRate: bigint,
  userEmissionRate: bigint,
  stakedValueInHubToken: bigint,
  userStakedValueInHubToken: bigint,
  averageInterestRatePerSecond: bigint,
  userInterestRatePerSecond: bigint,
  stakeableTokens: string[],
  stakedAmounts: bigint[],
  userStakedAmounts: bigint[],
  underlyingTokens: string[],
  stakedUnderlying: bigint[],
  userUnderlying: bigint[],
  bribes: BribeDataStructOutput[]
] & {
  gauge: string;
  poolData: PoolDataStructOutput;
  killed: boolean;
  totalVotes: bigint;
  userVotes: bigint;
  userClaimable: bigint;
  emissionRate: bigint;
  userEmissionRate: bigint;
  stakedValueInHubToken: bigint;
  userStakedValueInHubToken: bigint;
  averageInterestRatePerSecond: bigint;
  userInterestRatePerSecond: bigint;
  stakeableTokens: string[];
  stakedAmounts: bigint[];
  userStakedAmounts: bigint[];
  underlyingTokens: string[];
  stakedUnderlying: bigint[];
  userUnderlying: bigint[];
  bribes: BribeDataStructOutput[];
};

export declare namespace VaultStorage {
  export type FacetCutStruct = {
    facetAddress: AddressLike;
    action: BigNumberish;
    functionSelectors: BytesLike[];
  };

  export type FacetCutStructOutput = [
    facetAddress: string,
    action: bigint,
    functionSelectors: string[]
  ] & { facetAddress: string; action: bigint; functionSelectors: string[] };
}

export interface VelocoreInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "canonicalPoolLength"
      | "canonicalPools"
      | "getPoolBalance"
      | "queryGauge"
      | "queryPool"
      | "spotPrice"
      | "userBalances"
      | "wombatGauges"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "BribeAttached"
      | "BribeKilled"
      | "Convert"
      | "DiamondCut"
      | "Gauge"
      | "GaugeKilled"
      | "Swap"
      | "UserBalance"
      | "Vote"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "canonicalPoolLength",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "canonicalPools",
    values: [AddressLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getPoolBalance",
    values: [AddressLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "queryGauge",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "queryPool",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "spotPrice",
    values: [BytesLike, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "userBalances",
    values: [AddressLike, BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "wombatGauges",
    values: [AddressLike]
  ): string;

  decodeFunctionResult(
    functionFragment: "canonicalPoolLength",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "canonicalPools",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPoolBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "queryGauge", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "queryPool", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "spotPrice", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "userBalances",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "wombatGauges",
    data: BytesLike
  ): Result;
}

export namespace BribeAttachedEvent {
  export type InputTuple = [gauge: AddressLike, bribe: AddressLike];
  export type OutputTuple = [gauge: string, bribe: string];
  export interface OutputObject {
    gauge: string;
    bribe: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace BribeKilledEvent {
  export type InputTuple = [gauge: AddressLike, bribe: AddressLike];
  export type OutputTuple = [gauge: string, bribe: string];
  export interface OutputObject {
    gauge: string;
    bribe: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ConvertEvent {
  export type InputTuple = [
    pool: AddressLike,
    user: AddressLike,
    tokenRef: BytesLike[],
    delta: BigNumberish[]
  ];
  export type OutputTuple = [
    pool: string,
    user: string,
    tokenRef: string[],
    delta: bigint[]
  ];
  export interface OutputObject {
    pool: string;
    user: string;
    tokenRef: string[];
    delta: bigint[];
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace DiamondCutEvent {
  export type InputTuple = [
    _diamondCut: VaultStorage.FacetCutStruct[],
    _init: AddressLike,
    _calldata: BytesLike
  ];
  export type OutputTuple = [
    _diamondCut: VaultStorage.FacetCutStructOutput[],
    _init: string,
    _calldata: string
  ];
  export interface OutputObject {
    _diamondCut: VaultStorage.FacetCutStructOutput[];
    _init: string;
    _calldata: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace GaugeEvent {
  export type InputTuple = [
    pool: AddressLike,
    user: AddressLike,
    tokenRef: BytesLike[],
    delta: BigNumberish[]
  ];
  export type OutputTuple = [
    pool: string,
    user: string,
    tokenRef: string[],
    delta: bigint[]
  ];
  export interface OutputObject {
    pool: string;
    user: string;
    tokenRef: string[];
    delta: bigint[];
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace GaugeKilledEvent {
  export type InputTuple = [gauge: AddressLike, killed: boolean];
  export type OutputTuple = [gauge: string, killed: boolean];
  export interface OutputObject {
    gauge: string;
    killed: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SwapEvent {
  export type InputTuple = [
    pool: AddressLike,
    user: AddressLike,
    tokenRef: BytesLike[],
    delta: BigNumberish[]
  ];
  export type OutputTuple = [
    pool: string,
    user: string,
    tokenRef: string[],
    delta: bigint[]
  ];
  export interface OutputObject {
    pool: string;
    user: string;
    tokenRef: string[];
    delta: bigint[];
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace UserBalanceEvent {
  export type InputTuple = [
    to: AddressLike,
    from: AddressLike,
    tokenRef: BytesLike[],
    delta: BigNumberish[]
  ];
  export type OutputTuple = [
    to: string,
    from: string,
    tokenRef: string[],
    delta: bigint[]
  ];
  export interface OutputObject {
    to: string;
    from: string;
    tokenRef: string[];
    delta: bigint[];
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace VoteEvent {
  export type InputTuple = [
    pool: AddressLike,
    user: AddressLike,
    voteDelta: BigNumberish
  ];
  export type OutputTuple = [pool: string, user: string, voteDelta: bigint];
  export interface OutputObject {
    pool: string;
    user: string;
    voteDelta: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface Velocore extends BaseContract {
  connect(runner?: ContractRunner | null): Velocore;
  waitForDeployment(): Promise<this>;

  interface: VelocoreInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  canonicalPoolLength: TypedContractMethod<[], [bigint], "nonpayable">;

  canonicalPools: TypedContractMethod<
    [user: AddressLike, begin: BigNumberish, maxLength: BigNumberish],
    [GaugeDataStructOutput[]],
    "nonpayable"
  >;

  getPoolBalance: TypedContractMethod<
    [poolAddr: AddressLike, token: BytesLike],
    [bigint],
    "view"
  >;

  queryGauge: TypedContractMethod<
    [gauge: AddressLike, user: AddressLike],
    [GaugeDataStructOutput],
    "nonpayable"
  >;

  queryPool: TypedContractMethod<
    [pool: AddressLike],
    [PoolDataStructOutput],
    "nonpayable"
  >;

  spotPrice: TypedContractMethod<
    [base: BytesLike, quote: BytesLike, amount: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  userBalances: TypedContractMethod<
    [user: AddressLike, ts: BytesLike[]],
    [bigint[]],
    "view"
  >;

  wombatGauges: TypedContractMethod<
    [user: AddressLike],
    [GaugeDataStructOutput[]],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "canonicalPoolLength"
  ): TypedContractMethod<[], [bigint], "nonpayable">;
  getFunction(
    nameOrSignature: "canonicalPools"
  ): TypedContractMethod<
    [user: AddressLike, begin: BigNumberish, maxLength: BigNumberish],
    [GaugeDataStructOutput[]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getPoolBalance"
  ): TypedContractMethod<
    [poolAddr: AddressLike, token: BytesLike],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "queryGauge"
  ): TypedContractMethod<
    [gauge: AddressLike, user: AddressLike],
    [GaugeDataStructOutput],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "queryPool"
  ): TypedContractMethod<
    [pool: AddressLike],
    [PoolDataStructOutput],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "spotPrice"
  ): TypedContractMethod<
    [base: BytesLike, quote: BytesLike, amount: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "userBalances"
  ): TypedContractMethod<
    [user: AddressLike, ts: BytesLike[]],
    [bigint[]],
    "view"
  >;
  getFunction(
    nameOrSignature: "wombatGauges"
  ): TypedContractMethod<
    [user: AddressLike],
    [GaugeDataStructOutput[]],
    "nonpayable"
  >;

  getEvent(
    key: "BribeAttached"
  ): TypedContractEvent<
    BribeAttachedEvent.InputTuple,
    BribeAttachedEvent.OutputTuple,
    BribeAttachedEvent.OutputObject
  >;
  getEvent(
    key: "BribeKilled"
  ): TypedContractEvent<
    BribeKilledEvent.InputTuple,
    BribeKilledEvent.OutputTuple,
    BribeKilledEvent.OutputObject
  >;
  getEvent(
    key: "Convert"
  ): TypedContractEvent<
    ConvertEvent.InputTuple,
    ConvertEvent.OutputTuple,
    ConvertEvent.OutputObject
  >;
  getEvent(
    key: "DiamondCut"
  ): TypedContractEvent<
    DiamondCutEvent.InputTuple,
    DiamondCutEvent.OutputTuple,
    DiamondCutEvent.OutputObject
  >;
  getEvent(
    key: "Gauge"
  ): TypedContractEvent<
    GaugeEvent.InputTuple,
    GaugeEvent.OutputTuple,
    GaugeEvent.OutputObject
  >;
  getEvent(
    key: "GaugeKilled"
  ): TypedContractEvent<
    GaugeKilledEvent.InputTuple,
    GaugeKilledEvent.OutputTuple,
    GaugeKilledEvent.OutputObject
  >;
  getEvent(
    key: "Swap"
  ): TypedContractEvent<
    SwapEvent.InputTuple,
    SwapEvent.OutputTuple,
    SwapEvent.OutputObject
  >;
  getEvent(
    key: "UserBalance"
  ): TypedContractEvent<
    UserBalanceEvent.InputTuple,
    UserBalanceEvent.OutputTuple,
    UserBalanceEvent.OutputObject
  >;
  getEvent(
    key: "Vote"
  ): TypedContractEvent<
    VoteEvent.InputTuple,
    VoteEvent.OutputTuple,
    VoteEvent.OutputObject
  >;

  filters: {
    "BribeAttached(address,address)": TypedContractEvent<
      BribeAttachedEvent.InputTuple,
      BribeAttachedEvent.OutputTuple,
      BribeAttachedEvent.OutputObject
    >;
    BribeAttached: TypedContractEvent<
      BribeAttachedEvent.InputTuple,
      BribeAttachedEvent.OutputTuple,
      BribeAttachedEvent.OutputObject
    >;

    "BribeKilled(address,address)": TypedContractEvent<
      BribeKilledEvent.InputTuple,
      BribeKilledEvent.OutputTuple,
      BribeKilledEvent.OutputObject
    >;
    BribeKilled: TypedContractEvent<
      BribeKilledEvent.InputTuple,
      BribeKilledEvent.OutputTuple,
      BribeKilledEvent.OutputObject
    >;

    "Convert(address,address,bytes32[],int128[])": TypedContractEvent<
      ConvertEvent.InputTuple,
      ConvertEvent.OutputTuple,
      ConvertEvent.OutputObject
    >;
    Convert: TypedContractEvent<
      ConvertEvent.InputTuple,
      ConvertEvent.OutputTuple,
      ConvertEvent.OutputObject
    >;

    "DiamondCut(tuple[],address,bytes)": TypedContractEvent<
      DiamondCutEvent.InputTuple,
      DiamondCutEvent.OutputTuple,
      DiamondCutEvent.OutputObject
    >;
    DiamondCut: TypedContractEvent<
      DiamondCutEvent.InputTuple,
      DiamondCutEvent.OutputTuple,
      DiamondCutEvent.OutputObject
    >;

    "Gauge(address,address,bytes32[],int128[])": TypedContractEvent<
      GaugeEvent.InputTuple,
      GaugeEvent.OutputTuple,
      GaugeEvent.OutputObject
    >;
    Gauge: TypedContractEvent<
      GaugeEvent.InputTuple,
      GaugeEvent.OutputTuple,
      GaugeEvent.OutputObject
    >;

    "GaugeKilled(address,bool)": TypedContractEvent<
      GaugeKilledEvent.InputTuple,
      GaugeKilledEvent.OutputTuple,
      GaugeKilledEvent.OutputObject
    >;
    GaugeKilled: TypedContractEvent<
      GaugeKilledEvent.InputTuple,
      GaugeKilledEvent.OutputTuple,
      GaugeKilledEvent.OutputObject
    >;

    "Swap(address,address,bytes32[],int128[])": TypedContractEvent<
      SwapEvent.InputTuple,
      SwapEvent.OutputTuple,
      SwapEvent.OutputObject
    >;
    Swap: TypedContractEvent<
      SwapEvent.InputTuple,
      SwapEvent.OutputTuple,
      SwapEvent.OutputObject
    >;

    "UserBalance(address,address,bytes32[],int128[])": TypedContractEvent<
      UserBalanceEvent.InputTuple,
      UserBalanceEvent.OutputTuple,
      UserBalanceEvent.OutputObject
    >;
    UserBalance: TypedContractEvent<
      UserBalanceEvent.InputTuple,
      UserBalanceEvent.OutputTuple,
      UserBalanceEvent.OutputObject
    >;

    "Vote(address,address,int256)": TypedContractEvent<
      VoteEvent.InputTuple,
      VoteEvent.OutputTuple,
      VoteEvent.OutputObject
    >;
    Vote: TypedContractEvent<
      VoteEvent.InputTuple,
      VoteEvent.OutputTuple,
      VoteEvent.OutputObject
    >;
  };
}
