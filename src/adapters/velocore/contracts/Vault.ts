/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "./common";

export type VelocoreOperationStruct = {
  poolId: BytesLike;
  tokenInformations: BytesLike[];
  data: BytesLike;
};

export type VelocoreOperationStructOutput = [
  poolId: string,
  tokenInformations: string[],
  data: string
] & { poolId: string; tokenInformations: string[]; data: string };

export interface VaultInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "admin_addFacet"
      | "admin_setAuthorizer"
      | "admin_setFunctions"
      | "attachBribe"
      | "ballotToken"
      | "emissionToken"
      | "execute"
      | "inspect"
      | "notifyInitialSupply"
      | "query"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "Convert"
      | "Gauge"
      | "Swap"
      | "UserBalance"
      | "Vote"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "admin_addFacet",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "admin_setAuthorizer",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "admin_setFunctions",
    values: [AddressLike, BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "attachBribe",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "ballotToken",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "emissionToken",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "execute",
    values: [BytesLike[], BigNumberish[], VelocoreOperationStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "inspect",
    values: [AddressLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "notifyInitialSupply",
    values: [BytesLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "query",
    values: [
      AddressLike,
      BytesLike[],
      BigNumberish[],
      VelocoreOperationStruct[]
    ]
  ): string;

  decodeFunctionResult(
    functionFragment: "admin_addFacet",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "admin_setAuthorizer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "admin_setFunctions",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "attachBribe",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "ballotToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "emissionToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "execute", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "inspect", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "notifyInitialSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "query", data: BytesLike): Result;
}

export namespace ConvertEvent {
  export type InputTuple = [
    pool: AddressLike,
    user: AddressLike,
    tokenRef: BytesLike[],
    delta: BigNumberish[]
  ];
  export type OutputTuple = [
    pool: string,
    user: string,
    tokenRef: string[],
    delta: bigint[]
  ];
  export interface OutputObject {
    pool: string;
    user: string;
    tokenRef: string[];
    delta: bigint[];
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace GaugeEvent {
  export type InputTuple = [
    pool: AddressLike,
    user: AddressLike,
    tokenRef: BytesLike[],
    delta: BigNumberish[]
  ];
  export type OutputTuple = [
    pool: string,
    user: string,
    tokenRef: string[],
    delta: bigint[]
  ];
  export interface OutputObject {
    pool: string;
    user: string;
    tokenRef: string[];
    delta: bigint[];
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SwapEvent {
  export type InputTuple = [
    pool: AddressLike,
    user: AddressLike,
    tokenRef: BytesLike[],
    delta: BigNumberish[]
  ];
  export type OutputTuple = [
    pool: string,
    user: string,
    tokenRef: string[],
    delta: bigint[]
  ];
  export interface OutputObject {
    pool: string;
    user: string;
    tokenRef: string[];
    delta: bigint[];
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace UserBalanceEvent {
  export type InputTuple = [
    to: AddressLike,
    from: AddressLike,
    tokenRef: BytesLike[],
    delta: BigNumberish[]
  ];
  export type OutputTuple = [
    to: string,
    from: string,
    tokenRef: string[],
    delta: bigint[]
  ];
  export interface OutputObject {
    to: string;
    from: string;
    tokenRef: string[];
    delta: bigint[];
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace VoteEvent {
  export type InputTuple = [
    pool: AddressLike,
    user: AddressLike,
    voteDelta: BigNumberish
  ];
  export type OutputTuple = [pool: string, user: string, voteDelta: bigint];
  export interface OutputObject {
    pool: string;
    user: string;
    voteDelta: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface Vault extends BaseContract {
  connect(runner?: ContractRunner | null): Vault;
  waitForDeployment(): Promise<this>;

  interface: VaultInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  admin_addFacet: TypedContractMethod<
    [implementation: AddressLike],
    [void],
    "nonpayable"
  >;

  admin_setAuthorizer: TypedContractMethod<
    [auth_: AddressLike],
    [void],
    "nonpayable"
  >;

  admin_setFunctions: TypedContractMethod<
    [implementation: AddressLike, sigs: BytesLike[]],
    [void],
    "nonpayable"
  >;

  attachBribe: TypedContractMethod<
    [gauge: AddressLike, bribe: AddressLike],
    [void],
    "nonpayable"
  >;

  ballotToken: TypedContractMethod<[], [string], "nonpayable">;

  emissionToken: TypedContractMethod<[], [string], "nonpayable">;

  execute: TypedContractMethod<
    [
      tokenRef: BytesLike[],
      deposit: BigNumberish[],
      ops: VelocoreOperationStruct[]
    ],
    [void],
    "payable"
  >;

  inspect: TypedContractMethod<
    [lens: AddressLike, data: BytesLike],
    [void],
    "nonpayable"
  >;

  notifyInitialSupply: TypedContractMethod<
    [arg0: BytesLike, arg1: BigNumberish, arg2: BigNumberish],
    [void],
    "nonpayable"
  >;

  query: TypedContractMethod<
    [
      user: AddressLike,
      tokenRef: BytesLike[],
      deposit: BigNumberish[],
      ops: VelocoreOperationStruct[]
    ],
    [bigint[]],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "admin_addFacet"
  ): TypedContractMethod<[implementation: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "admin_setAuthorizer"
  ): TypedContractMethod<[auth_: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "admin_setFunctions"
  ): TypedContractMethod<
    [implementation: AddressLike, sigs: BytesLike[]],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "attachBribe"
  ): TypedContractMethod<
    [gauge: AddressLike, bribe: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "ballotToken"
  ): TypedContractMethod<[], [string], "nonpayable">;
  getFunction(
    nameOrSignature: "emissionToken"
  ): TypedContractMethod<[], [string], "nonpayable">;
  getFunction(
    nameOrSignature: "execute"
  ): TypedContractMethod<
    [
      tokenRef: BytesLike[],
      deposit: BigNumberish[],
      ops: VelocoreOperationStruct[]
    ],
    [void],
    "payable"
  >;
  getFunction(
    nameOrSignature: "inspect"
  ): TypedContractMethod<
    [lens: AddressLike, data: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "notifyInitialSupply"
  ): TypedContractMethod<
    [arg0: BytesLike, arg1: BigNumberish, arg2: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "query"
  ): TypedContractMethod<
    [
      user: AddressLike,
      tokenRef: BytesLike[],
      deposit: BigNumberish[],
      ops: VelocoreOperationStruct[]
    ],
    [bigint[]],
    "nonpayable"
  >;

  getEvent(
    key: "Convert"
  ): TypedContractEvent<
    ConvertEvent.InputTuple,
    ConvertEvent.OutputTuple,
    ConvertEvent.OutputObject
  >;
  getEvent(
    key: "Gauge"
  ): TypedContractEvent<
    GaugeEvent.InputTuple,
    GaugeEvent.OutputTuple,
    GaugeEvent.OutputObject
  >;
  getEvent(
    key: "Swap"
  ): TypedContractEvent<
    SwapEvent.InputTuple,
    SwapEvent.OutputTuple,
    SwapEvent.OutputObject
  >;
  getEvent(
    key: "UserBalance"
  ): TypedContractEvent<
    UserBalanceEvent.InputTuple,
    UserBalanceEvent.OutputTuple,
    UserBalanceEvent.OutputObject
  >;
  getEvent(
    key: "Vote"
  ): TypedContractEvent<
    VoteEvent.InputTuple,
    VoteEvent.OutputTuple,
    VoteEvent.OutputObject
  >;

  filters: {
    "Convert(address,address,bytes32[],int128[])": TypedContractEvent<
      ConvertEvent.InputTuple,
      ConvertEvent.OutputTuple,
      ConvertEvent.OutputObject
    >;
    Convert: TypedContractEvent<
      ConvertEvent.InputTuple,
      ConvertEvent.OutputTuple,
      ConvertEvent.OutputObject
    >;

    "Gauge(address,address,bytes32[],int128[])": TypedContractEvent<
      GaugeEvent.InputTuple,
      GaugeEvent.OutputTuple,
      GaugeEvent.OutputObject
    >;
    Gauge: TypedContractEvent<
      GaugeEvent.InputTuple,
      GaugeEvent.OutputTuple,
      GaugeEvent.OutputObject
    >;

    "Swap(address,address,bytes32[],int128[])": TypedContractEvent<
      SwapEvent.InputTuple,
      SwapEvent.OutputTuple,
      SwapEvent.OutputObject
    >;
    Swap: TypedContractEvent<
      SwapEvent.InputTuple,
      SwapEvent.OutputTuple,
      SwapEvent.OutputObject
    >;

    "UserBalance(address,address,bytes32[],int128[])": TypedContractEvent<
      UserBalanceEvent.InputTuple,
      UserBalanceEvent.OutputTuple,
      UserBalanceEvent.OutputObject
    >;
    UserBalance: TypedContractEvent<
      UserBalanceEvent.InputTuple,
      UserBalanceEvent.OutputTuple,
      UserBalanceEvent.OutputObject
    >;

    "Vote(address,address,int256)": TypedContractEvent<
      VoteEvent.InputTuple,
      VoteEvent.OutputTuple,
      VoteEvent.OutputObject
    >;
    Vote: TypedContractEvent<
      VoteEvent.InputTuple,
      VoteEvent.OutputTuple,
      VoteEvent.OutputObject
    >;
  };
}
